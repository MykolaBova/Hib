package org.julp;

import java.beans.BeanInfo;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import net.sf.cglib.core.NamingPolicy;
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

/**
 * CGLibInstantiator instantiates class and enhances it to make it persistable. Also it can enhanced already instantiated class. Keep in mind the class name of instantiated or enhanced object will be
 * different. In fact it will be descendant (inherited) from the passed class/object. The class name is defined by <code>NamingPolicy</code>. By default the policy implementation is <code>org.julp.CGLibNamingPolicy</code>
 * If you set naming policy to null the class name will be generated by CGLib. It will be like this: [Your class name]$$EnhancerByCGLIB$$[some alphanumeric] i.e. Customer$$EnhancerByCGLIB$$d8f6a6bd.
 * You can change it by implementing <code>NamingPolicy</code> yourself.
 */
public class CGLibInstantiator<T> implements Instantiator<T> {

    private static final long serialVersionUID = -1556016275740948314L;
    private static Map<String, Method> abstractDomainObjectMethods = new HashMap<>(); //AbstractDomainObject.class.getMethods();
    /**
     * Execute methods of superclass rather then AbstractDomainObject methods if they have the same names
     */
    private Set<String> abstractDomainObjectMethodsToSkip;
    private Class<T> instanceClass;
    private Class<?>[] instanceInterfaces;
    private transient Method[] instanceMethods;
    private DomainObjectInterceptor interceptor;
    private final Enhancer enhancer = new Enhancer();
    private Map<String, Method> writeMethods;
    private Map<String, Method> readMethods;
    private boolean defaultNamingPolicy;
    private NamingPolicy namingPolicy = new CGLibNamingPolicy();
//    private boolean delegate;

    public CGLibInstantiator() {

    }

    public CGLibInstantiator(NamingPolicy namingPolicy) {
        this.namingPolicy = namingPolicy;
    }

    public CGLibInstantiator(NamingPolicy namingPolicy, Set<String> abstractDomainObjectMethodsToSkip) {
        this.namingPolicy = namingPolicy;
        this.abstractDomainObjectMethodsToSkip = abstractDomainObjectMethodsToSkip;
    }

    public CGLibInstantiator(Set<String> abstractDomainObjectMethodsToSkip) {
        this.abstractDomainObjectMethodsToSkip = abstractDomainObjectMethodsToSkip;
    }

    private void init() {
        synchronized (this) {
            if (abstractDomainObjectMethods.isEmpty()) {
                //abstractDomainObjectMethods = AbstractDomainObject.class.getMethods();
                for (Method m : AbstractDomainObject.class.getMethods()) {
                    if ((abstractDomainObjectMethodsToSkip != null
                            && abstractDomainObjectMethodsToSkip.contains(m.getName()))
                            || (m.getName().equals("hashCode")
                            || m.getName().equals("wait")
                            || m.getName().equals("equals")
                            || m.getName().equals("getClass")
                            || m.getName().equals("notify")
                            || m.getName().equals("notifyAll"))) {
                        // do nothing
                    } else {
                        abstractDomainObjectMethods.put(m.getName(), m);
                    }
                }
            }
        }
    }

    @Override
    public Set<String> getAbstractDomainObjectMethodsToSkip() {
        return abstractDomainObjectMethodsToSkip;
    }

    @Override
    public void setAbstractDomainObjectMethodsToSkip(Set<String> methodsToSkip) {
        abstractDomainObjectMethodsToSkip = methodsToSkip;
    }

    private Method getInstanceMethod(String methodName) {
        for (Method m : instanceMethods) {
            if (m.getName().equals(methodName)) {
                return m;
            }
        }
        return null;
    }

    @Override
    public T newInstance(Class<T> instanceClass) {
        try {
            return process((T) instanceClass.newInstance());
        } catch (Exception e) {
            throw new DataAccessException(e);
        }
    }

    @Override
    public T enhance(T instance) {
        return process(instance);
    }

    @SuppressWarnings("unchecked")
    protected T process(T instance) {
        if (instance != null) {
            if (instanceClass != null) {
                if (!instanceClass.equals(instance.getClass())) {
                    instanceMethods = instance.getClass().getMethods();
                    instanceClass = (Class<T>) instance.getClass();
                }
            } else {
                instanceMethods = instance.getClass().getMethods();
                instanceClass = (Class<T>) instance.getClass();
            }
        } else {
            throw new DataAccessException("Instance is null");
        }

        init();

        if (instanceClass != null && instance.getClass().equals(instanceClass)) {
            if (instanceInterfaces != null) {
                enhancer.setInterfaces(instanceInterfaces);
            } else {
                enhancer.setSuperclass(instanceClass);
                buildInterfaces(instance);
                enhancer.setInterfaces(instanceInterfaces);
            }
        } else {
            enhancer.setSuperclass(instance.getClass());
            buildInterfaces(instance);
            enhancer.setInterfaces(instanceInterfaces);
        }

        interceptor = new DomainObjectInterceptor(instance);
        enhancer.setCallback(interceptor);
        if (namingPolicy != null) {
            enhancer.setNamingPolicy(namingPolicy);
        }

        return (T) enhancer.create();
    }

    protected void buildInterfaces(T instance) {
        Class<?>[] origInterfaces = instance.getClass().getInterfaces();
        boolean foundDomainObject = false;
        boolean foundSerializable = false;
        for (Class<?> c : origInterfaces) {
            if (DomainObject.class.isAssignableFrom(c)) {
                foundDomainObject = true;
                if (foundDomainObject && foundSerializable) {
                    break;
                }
            }
            if (Serializable.class.isAssignableFrom(c)) {
                foundSerializable = true;
                if (foundDomainObject && foundSerializable) {
                    break;
                }
            }
        }

        if (!foundDomainObject && !foundSerializable) {
            instanceInterfaces = new Class<?>[origInterfaces.length + 2];
            System.arraycopy(origInterfaces, 0, instanceInterfaces, 0, origInterfaces.length);
            instanceInterfaces[instanceInterfaces.length - 2] = DomainObject.class;
            instanceInterfaces[instanceInterfaces.length - 1] = Serializable.class;
        } else if (!foundDomainObject) {
            instanceInterfaces = new Class<?>[origInterfaces.length + 1];
            System.arraycopy(origInterfaces, 0, instanceInterfaces, 0, origInterfaces.length);
            instanceInterfaces[instanceInterfaces.length - 1] = DomainObject.class;
        } else if (!foundSerializable) {
            instanceInterfaces = new Class<?>[origInterfaces.length + 1];
            System.arraycopy(origInterfaces, 0, instanceInterfaces, 0, origInterfaces.length);
            instanceInterfaces[instanceInterfaces.length - 1] = Serializable.class;
        }
    }

    public boolean isDefaultNamingPolicy() {
        return defaultNamingPolicy;
    }

    public void setDefaultNamingPolicy(boolean defaultNamingPolicy) {
        this.defaultNamingPolicy = defaultNamingPolicy;
    }

    @Override
    public boolean isEnhanced(T instance) {
        return Enhancer.isEnhanced(instance.getClass());
    }
    
    public NamingPolicy getNamingPolicy() {
        return namingPolicy;
    }

    public void setNamingPolicy(NamingPolicy namingPolicy) {
        this.namingPolicy = namingPolicy;
    }

    private class DomainObjectInterceptor implements MethodInterceptor, Serializable {

        private static final long serialVersionUID = 1L;
        private DomainObject<T> innerDomainObject;
        private T instance;

        DomainObjectInterceptor(T instance) {
            innerDomainObject = new InnerDomainObject<>();
            this.instance = instance;
        }

        public void reattach(T instance) {
            if (instance == null) {
                throw new DataAccessException("Instance is null");
            }
            if (!instance.getClass().equals(instanceClass)) {
                throw new ClassCastException(instance.getClass() + " cannot be cast to " + instanceClass);
            }
            this.instance = instance;
        }

        public T detach() {
            return instance;
        }

        @SuppressWarnings("unchecked")
        private boolean load(Object obj) {
            ((DomainObject<T>) obj).setLoading(true);
            DataHolder originalValues = ((DomainObject<T>) obj).getOriginalValues();
            if (originalValues != null && originalValues.getFieldsCount() > 0) {
                try {
                    Object[] param = new Object[1];
                    for (int fieldIndex = 1; fieldIndex <= originalValues.getFieldsCount(); fieldIndex++) {
                        param[0] = null;
                        String fieldName = originalValues.getFieldName(fieldIndex);
                        Object value = originalValues.getFieldValue(fieldIndex);
                        if (writeMethods == null) {
                            writeMethods = new HashMap<>();
                        }
                        if (!writeMethods.containsKey(fieldName)) {
                            PropertyDescriptor pd = new PropertyDescriptor(fieldName, obj.getClass());
                            writeMethods.put(fieldName, pd.getWriteMethod());
                        }
                        param[0] = value;
                        writeValue(obj, writeMethods.get(fieldName), param);
                    }
                } catch (Throwable t) {
                    throw new DataAccessException(t);
                }
                ((DomainObject<T>) obj).setLoading(false);
                ((DomainObject<T>) obj).setLoaded(true);
                ((DomainObject<T>) obj).setModified(false);
                return true;
            }
            ((DomainObject<T>) obj).setLoading(false);
            return false;
        }

        @SuppressWarnings("unchecked")
        private boolean syncOriginal(Object obj) {
            boolean sync = false;
            DataHolder originalValues = ((DomainObject<T>) obj).getOriginalValues();
            if (originalValues != null && originalValues.getFieldsCount() > 0) {
                try {
                    if (((DomainObject<T>) obj).getPersistentState() == PersistentState.REMOVED) {
                        ((DomainObject<T>) obj).setPersistentState(PersistentState.UNDEFINED);
                    } else {
                        ((DomainObject<T>) obj).setPersistentState(PersistentState.ORIGINAL);
                    }
                    for (int fieldIndex = 1; fieldIndex <= originalValues.getFieldsCount(); fieldIndex++) {
                        String fieldName = originalValues.getFieldName(fieldIndex);
                        Object value;
                        if (readMethods == null) {
                            readMethods = new HashMap<>();
                        }
                        if (!readMethods.containsKey(fieldName)) {
                            PropertyDescriptor pd = new PropertyDescriptor(fieldName, obj.getClass());
                            readMethods.put(fieldName, pd.getReadMethod());
                        }
                        value = readValue(readMethods.get(fieldName), obj);
                        originalValues.setFieldValue(fieldIndex, value);
                    }
                    sync = true;
                    ((DomainObject<T>) obj).setModified(false);
                } catch (Throwable t) {
                    throw new DataAccessException(t);
                }
            }
            return sync;
        }

        private Object readValue(Method method, Object obj) throws Throwable {
            Object value = null;
            try {
                value = method.invoke(obj, EMPTY_ARG);
            } catch (Throwable t) {
                if (t instanceof InvocationTargetException) {
                    throw ((InvocationTargetException) t).getTargetException();
                } else {
                    throw t;
                }
            }
            return value;
        }

        private void writeValue(Object obj, Method method, Object[] value) throws Throwable {
            try {
                method.invoke(obj, value);
            } catch (Throwable t) {
                if (t instanceof InvocationTargetException) {
                    throw ((InvocationTargetException) t).getTargetException();
                } else {
                    throw t;
                }
            }
        }

        private StringBuilder toStringBuilder(Object object) {
            StringBuilder sb = new StringBuilder();
            Object value;
            Method[] methods = object.getClass().getMethods();

            for (int i = 0; i < methods.length; i++) {
                String methodName = methods[i].getName();
                if (methodName.equals("getClass")
                        || methodName.equals("hashCode")
                        || methodName.equals("wait")
                        || methodName.equals("equals")
                        || methodName.equals("notify")
                        || methodName.equals("notifyAll")
                        || methodName.equals("getCallback")
                        || methodName.equals("getCallbacks")
                        || abstractDomainObjectMethods.containsKey(methodName)
                        || (!innerDomainObject.isDisplayInternalMethods() && innerDomainObject.getInternalMethods().contains(methodName))) {
                    continue;
                }
                if ((methodName.startsWith("get") || methodName.startsWith("is")) && methods[i].getParameterTypes().length == 0) {
                    try {
                        value = methods[i].invoke(object, new Object[0]);
                    } catch (Throwable t) {
                        continue;
                    }
                    String fieldFirstChar;
                    if (methodName.startsWith("is")) {
                        fieldFirstChar = methodName.substring(2, 3).toLowerCase();
                        sb.append(fieldFirstChar);
                        sb.append(methodName.substring(3));
                    } else if (methodName.startsWith("get")) {
                        fieldFirstChar = methodName.substring(3, 4).toLowerCase();
                        sb.append(fieldFirstChar);
                        sb.append(methodName.substring(4));
                    }
                    sb.append("=");
                    sb.append((value == null) ? "" : value);
                    sb.append("&");
                }
            }
            sb.deleteCharAt(sb.lastIndexOf("&"));
            return sb;
        }

        @SuppressWarnings("unchecked")
        @Override
        public Object intercept(Object obj, Method method, Object[] param, MethodProxy mp) throws Throwable {
            Object value = null;
            if (abstractDomainObjectMethods.containsKey(method.getName())) {
                if (method.getName().equals("load")) {
                    value = load(obj);
                } else if (method.getName().equals("syncOriginal")) {
                    value = syncOriginal(obj);
                } else if (method.getName().equals("detach")) {
                    value = detach();
                } else if (method.getName().equals("reattach")) {
                    reattach((T) param[0]);
                } else {
                    if (method.getName().equals("toString")) {
                        StringBuilder sb = toStringBuilder(obj);
                        value = sb.toString();
                    } else {
                        value = mp.invoke(innerDomainObject, param);
                    }
                }
            } else {
                if (!innerDomainObject.isLoading()) {
                    if (method.getName().startsWith("set")
                            && method.getParameterTypes().length == 1
                            && method.getReturnType() == Void.TYPE
                            && method.getModifiers() == Modifier.PUBLIC) {
                        abstractDomainObjectMethods.get("setModified").invoke(innerDomainObject, new Object[]{true});
                        ValueObject<?> oldValue;
                        if (innerDomainObject.getPropertyChangeSupport() != null) {
                            oldValue = getOldValue(obj, method);
//                            if (!delegate) {
//                                value = mp.invokeSuper(obj, param);
//                            } else  {
                            value = getInstanceMethod(method.getName()).invoke(instance, param);
//                            }
                            if (oldValue != null) {
                                innerDomainObject.getPropertyChangeSupport().firePropertyChange(oldValue.getValueLabel(), oldValue.getValue(), param[0]);
                            }
                        } else {
//                            if (!delegate) {
//                               value = mp.invokeSuper(obj, param);
//                            } else {
                            value = getInstanceMethod(method.getName()).invoke(instance, param);
//                            }
                        }
                    } else {
//                        if (!delegate) {
//                            value = mp.invokeSuper(obj, param);
//                        } else {
                        value = getInstanceMethod(method.getName()).invoke(instance, param);
//                        }
                    }
                } else {
//                    if (!delegate) {
//                        value = mp.invokeSuper(obj, param);
//                    } else {
                    value = getInstanceMethod(method.getName()).invoke(instance, param);
//                    }
                }
            }
            return value;
        }

        @SuppressWarnings({"unchecked", "rawtypes"})
        private ValueObject<?> getOldValue(Object obj, Method method) {
            ValueObject<?> oldValue = null;
            try {
                BeanInfo bi = Introspector.getBeanInfo(obj.getClass());
                PropertyDescriptor[] pds = bi.getPropertyDescriptors();
                for (PropertyDescriptor pd : pds) {
                    if (pd == null) {
                        continue;
                    }
                    Method wm = pd.getWriteMethod();
                    if (wm == null) {
                        continue;
                    }
                    if (method.getName().equals(wm.getName())) {
                        Method readMethod = pd.getReadMethod();
                        Object value = readMethod.invoke(obj, EMPTY_ARG);
                        String propertyName = pd.getName();
                        oldValue = new ValueObject(value, propertyName);
                        break;
                    }
                }
            } catch (Exception e) {
                throw new DataAccessException(e);
            }
            return oldValue;
        }
    }

    private static class InnerDomainObject<T> extends AbstractDomainObject<T> {

        private static final long serialVersionUID = 1L;

        InnerDomainObject() {}
    }
}
