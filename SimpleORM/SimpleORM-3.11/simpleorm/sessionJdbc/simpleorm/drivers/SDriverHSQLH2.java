/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package simpleorm.drivers;

import simpleorm.dataset.SFieldMeta;
import simpleorm.dataset.SFieldScalar;
import simpleorm.dataset.SRecordMeta;
import simpleorm.sessionjdbc.SDriver;
import simpleorm.sessionjdbc.SGenerator;

/**
 * Common code between HSQL and H2.
 * Note that thewe toy databases do not
 * support locking, so is not safe in multi user mode even with optimistic
 * locking. See {@link SDriver#supportsLocking}.
 * @author aberglas
 */
public abstract class SDriverHSQLH2 extends SDriver {
    
    	/** HSQL has a major hole but optimisic locking papers over it.  H2 might support locking?*/
	@Override public boolean supportsLocking() {
		return false;
	}

	@Override protected String columnTypeSQL(SFieldScalar field, String defalt) {
		if (defalt.equals("BYTES"))
			return "BINARY"; // Ie. just a byte array.
        else if ( defalt.equals("NUMERIC(18,0)") )
            return "BIGINT"; // NUMERIC(18,0) does not work for Insert IDENTITY key columns.
        else
			return defalt;
	}
    
    @Override protected String addInsertGenerator(SFieldMeta fld) {
        return " IDENTITY "; // see JdbcTrials.java
        // Full: GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)
    }

    /** If the Sequence object is used. */
	@Override protected long generateKeySequence(SRecordMeta<?> rec, SFieldScalar keyFld) {
    	Object sequenceName = ((SGenerator)keyFld.getGenerator()).getName();

		String qry = "CALL NEXT VALUE FOR " + (String) sequenceName;

		Object next = getSession().rawQuerySingle(qry, false);
		
		if (next == null)
			return 0;
		if (next instanceof Number)
			return ((Number) next).longValue();
		else
			return Long.parseLong(next.toString());
	}

	@Override public boolean supportsKeySequences() {
		return true;
	}

	@Override protected String createSequenceDDL(String name) {
		return "CREATE SEQUENCE " + name;
	}

	@Override protected String dropSequenceDDL(String name) {
		return "DROP SEQUENCE " + name;
	}

         /** Supports keys created during INSERTion of new records (MSSQL & MySQL Style). */
    @Override public boolean supportsInsertKeyGeneration() {
		return true;
	}

    @Override protected long retrieveInsertedKey(SRecordMeta<?> rec, SFieldScalar keyFld) {
		
		String qry = "CALL IDENTITY()";

		Object next = getSession().rawQuerySingle(qry, false);
		
		if (next == null)
			return 0;
		if (next instanceof Number)
			return ((Number) next).longValue();
		else
			return Long.parseLong(next.toString());
	}
    
    @Override
    protected OffsetStrategy getOffsetStrategy() {
        return OffsetStrategy.QUERY;
//		return OffsetStrategy.JDBC;
    }

    @Override
    protected String limitSQL(long offset, long limit) {
        StringBuffer sb = new StringBuffer();
        if (limit != Integer.MAX_VALUE) sb.append(" LIMIT " + limit);
        if (offset > 0) sb.append(" OFFSET " + offset);
        return sb.toString();
    }

}
